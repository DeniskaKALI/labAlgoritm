# Лабораторная работа №1  
**Тема:** Введение в алгоритмы. Сложность. Поиск.  
**Студент:** Островерхов Денис Юрьевич  
**Курс:** 3 курс, ПИЖ-б-о-23-1  

---

## Цель работы
- Освоить понятие вычислительной сложности алгоритма.  
- Получить практические навыки реализации и анализа линейного и бинарного поиска.  
- Научиться экспериментально подтверждать теоретические оценки сложности `O(n)` и `O(log n)`.

---

## Теоретическая часть

### Сложность алгоритма
Сложность алгоритма характеризует количество ресурсов (времени и памяти), необходимых алгоритму для обработки входных данных объема `n`.

### Асимптотический анализ
Анализ поведения алгоритма при стремлении `n` к бесконечности. Позволяет абстрагироваться от констант и аппаратных особенностей.

### O-нотация («О-большое»)
Верхняя асимптотическая оценка роста функции. Определяет наихудший сценарий работы алгоритма.

### Алгоритмы поиска

#### Линейный поиск (Linear Search)
- Последовательный перебор всех элементов массива.  
- Сложность: `O(n)`.

#### Бинарный поиск (Binary Search)
- Поиск в отсортированном массиве путем многократного деления интервала поиска пополам.  
- Сложность: `O(log n)`.  
- Требует предварительной сортировки массива (`O(n log n)`).

---

## Практическая часть

### Задание
1. Реализовать функцию линейного поиска элемента в массиве.  
2. Реализовать функцию бинарного поиска элемента в отсортированном массиве.  
3. Провести теоретический анализ сложности обоих алгоритмов.  
4. Экспериментально сравнить время выполнения алгоритмов на массивах разного размера.  
5. Визуализировать результаты, подтвердив асимптотику `O(n)` и `O(log n)`.

### Шаги выполнения
1. Создан файл `search_comparison.py`.  
2. Реализованы функции:
   - `linear_search(arr, target)` — линейный поиск.  
   - `binary_search(arr, target)` — бинарный поиск.  
   Каждая строка кода снабжена комментарием с асимптотической сложностью.
3. Подготовлены отсортированные массивы целых чисел разных размеров:  
   `[1000, 5000, 10000, 50000, 100000, 200000]`.  
   Выбраны различные цели поиска: первый, средний, последний и отсутствующий элемент.  
4. Проведен эмпирический анализ производительности с использованием `timeit`.  
   Замеры времени усреднены по 10 повторов.  
5. Построены графики зависимости времени выполнения от размера массива для обоих алгоритмов.

---

## Результаты экспериментов

### Характеристики ПК
- Процессор: Intel Core i5-1135G7 @ 2.40GHz  
- Оперативная память: 8 GB DDR4  
- ОС: Windows 11  
- Python: 3.11.6

### Таблица замеров времени
| Размер массива (N) | Linear (мс) | Linear/N (мкс) | Binary (мс) | Binary/logN (мкс) |
|------------------:|------------:|---------------:|------------:|-----------------:|
| 1 000             | 0.0266      | 0.0266         | 0.0017      | 0.1740           |
| 5 000             | 0.1351      | 0.0270         | 0.0015      | 0.1123           |
| 10 000            | 0.1333      | 0.0133         | 0.0014      | 0.1029           |
| 50 000            | 0.6813      | 0.0136         | 0.0019      | 0.1163           |
| 100 000           | 2.7910      | 0.0279         | 0.0022      | 0.1306           |
| 200 000           | 6.4943      | 0.0325         | 0.0026      | 0.1417           |

### Графики
1. **Линейный график:** показывает рост времени линейного поиска пропорционально `N` и логарифмический рост бинарного поиска.  
2. **Логарифмический график (log-scale по оси Y):** демонстрирует, что бинарный поиск растет почти как `log N`, подтверждая теоретическую оценку.

---

## Анализ результатов
1. Линейный поиск растет пропорционально размеру массива (`O(n)`).  
2. Бинарный поиск растет медленно, примерно как `log N`.  
3. На больших массивах бинарный поиск работает значительно быстрее.  
4. Практические результаты полностью соответствуют теоретическим оценкам.  
5. Выбор разных целей поиска (первый, средний, последний, отсутствующий) позволяет учитывать все сценарии работы алгоритма.

---

## Выводы
- Теоретическая сложность алгоритмов подтверждена на практике.  
- Линейный поиск подходит для небольших массивов или несортированных данных.  
- Бинарный поиск значительно эффективнее для больших отсортированных массивов.  
- Проведенный эксперимент демонстрирует важность выбора подходящего алгоритма для повышения производительности.

---

## Рекомендованная литература
1. Юрий Петров: "Программирование на Python" — [ссылка](https://www.yuripetrov.ru/edu/python/index.html)  
2. Кормен Т., Лейзерсон Ч., Ривест Р., Штайн К. *Алгоритмы: построение и анализ*, 3-е издание. М.: Вильямс, 2022.  
3. Скиена С. *Алгоритмы. Руководство по разработке*, 3-е издание. СПб.: БХВ-Петербург, 2022.  
